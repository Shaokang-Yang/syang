---
title: "Contact Information Look UP "
date: 03/10/2024
date-modified: last-modified
date-format: full
categories: [Paper1]
image: "lookup.png"
tbl-colwidths: [5,30,125]
format: 
  html:
    page-layout: full
---

In the aggregation of communication events of Paper 1, we only match the communication events with the contacts reported in the **current** wave of social network surveys. However, the current social network surveys are **not** enough to cover all the contacts in the communication events. For example, let’s say an individual communicated with contact **C** on a day in the spring semester of 2016. However, contact C was not reported in the survey of the 2016 spring; instead, contact C was reported in the survey of the 2015 Fall. Contact C is taken as **relation unknown** or **closeness unknown** if we only match communication with the current surveys. In paper 2, we meet the same issue while constructing an individual’s social networks. We solve it by looking up the missed contacts in a broaden pool of surveys. Specifically, we looking up the missed contacts in: 1) **complete** social network surveys in which the focal person participated; or, 2) surveys with limitations to the closest **N** neighboring waves. In this example, we can identify contact C’s social relationship and closeness in the survey of the fall of 2015.

In this update, we applied a similar look-up strategy for Paper 1. By doing this, the communication events from closeness unknown contacts and relationship unknown contacts decreased. In contrast, those from identified contacts increased. The following figures illustrate a comparison of the proportions of communication categories with different look-up strategies.

## Original Contacts (Without Look Up)

The following figure shows the categories of messages (SMS, MMS and WhatsApp) without look up 3 hours prior to sleep. The left column are the messages categorized by social closeness. We observe that **10.83** messages are from close unknown contacts, which accounts for **over 50%** of the total messages (20.36). The middle column shows the messages categorized by message type: SMS, MMS and WhatsApp. We find that the majority of the messages are SMS. The right column shows the messages categorized by social relationships. It suggests that **10.83** messages are from relation unknown contacts, which accounts for **over 50%** of the total messages (20.36). They are the same messages whose social closeness is unidentified in the left column.

```{python}
#| echo: false
#| warning: false
#| output: true
import time;import pandas as pd;import numpy as np;import datetime
from datetime import datetime;from datetime import timedelta;import sqlite3;import warnings
import matplotlib.pyplot as plt;import seaborn as sns;warnings.filterwarnings('ignore')

df=pd.read_csv("/Users/shaokangyang/Library/CloudStorage/OneDrive-Personal/Nethealth/Data/CNSA/combine/7/df7_3hr.csv")
import plotly.graph_objs as go
# Combine and format labels with their mean values for each category
# Close Degree labels with their means
labels_close_degree = [
    f'Especially Close: {df["especiallyclose_m"].mean():.2f}',
    f'Merely Close: {df["merelyclose_m"].mean():.2f}',
    f'Less Than Close: {df["lessthanclose_m"].mean():.2f}',
    f'Distant: {df["distant_m"].mean():.2f}',
    f'Close Unknown: {df["close_unknown_m"].mean():.2f}'
]

# Message Type labels with their means
labels_message_type = [
    f'SMS: {df["sms"].mean():.2f}',
    f'MMS: {df["mms"].mean():.2f}',
    f'WhatsApp: {df["whatsapp"].mean():.2f}'
]

# Contact Type labels with their means
labels_contact_type = [
    f'Acquaintance: {df["acquaintance_m"].mean():.2f}',
    f'Co-member Organization: {df["comemberorganization_m"].mean():.2f}',
    f'Coworker: {df["coworker_m"].mean():.2f}',
    f'Friend: {df["friend_m"].mean():.2f}',
    f'Neighbor: {df["neighbor_m"].mean():.2f}',
    f'Other Family: {df["otherfamily_m"].mean():.2f}',
    f'Romantic: {df["romantic_m"].mean():.2f}',
    f'Parent: {df["parent_m"].mean():.2f}',
    f'Step Parent: {df["stepparent_m"].mean():.2f}',
    f'Sibling: {df["sibling_m"].mean():.2f}',
    f'Step Sibling: {df["stepsibling_m"].mean():.2f}',
    f'Relation Unknown: {df["rela_unknown_m"].mean():.2f}'
]

# Combine all labels for nodes
labels = labels_close_degree + labels_message_type + labels_contact_type

# Initialize the lists for the source, target, and value arrays for the Sankey diagram
source = [
    # Close Degree to Message Type
    0, 0, 0,  # Especially Close to SMS, MMS, WhatsApp
    1, 1, 1,  # Merely Close to SMS, MMS, WhatsApp
    2, 2, 2,  # Less Than Close to SMS, MMS, WhatsApp
    3, 3, 3,  # Distant to SMS, MMS, WhatsApp
    4, 4, 4   # Close Unknown to SMS, MMS, WhatsApp
] + [
    # Message Type to Contact Type
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  # SMS to all contact types
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  # MMS to all contact types
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7   # WhatsApp to all contact types
]

target = [
    # Close Degree to Message Type
    5, 6, 7,  # Especially Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Merely Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Less Than Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Distant to SMS, MMS, WhatsApp
    5, 6, 7   # Close Unknown to SMS, MMS, WhatsApp
] + [
    # Message Type to Contact Type
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  # SMS to all contact types
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  # MMS to all contact types
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19   # WhatsApp to all contact types
]

# Values for all connections (assuming you have these means calculated correctly in your DataFrame)
#Judge if any of the following columns are not in the dataframe, create them and fill them with 0
for col in ['sms_acquaintance', 'sms_comemberorganization', 'sms_coworker', 'sms_friend', 'sms_neighbor', 'sms_otherfamily', 'sms_romanticpartner', 'sms_parent', 'sms_stepparent', 'sms_sibling', 'sms_stepsibling', 'sms_blank', 'mms_acquaintance', 'mms_comemberorganization', 'mms_coworker', 'mms_friend', 'mms_neighbor', 'mms_otherfamily', 'mms_romanticpartner', 'mms_parent', 'mms_stepparent', 'mms_sibling', 'mms_stepsibling', 'mms_blank', 'whatsapp_acquaintance', 'whatsapp_comemberorganization', 'whatsapp_coworker', 'whatsapp_friend', 'whatsapp_neighbor', 'whatsapp_otherfamily', 'whatsapp_romanticpartner', 'whatsapp_parent', 'whatsapp_stepparent', 'whatsapp_sibling', 'whatsapp_stepsibling', 'whatsapp_blank']:
    if col not in df.columns:
        df[col] = 0
value = [
    # Close Degree to Message Type values
    df['sms_especiallyclose'].mean(), df['mms_especiallyclose'].mean(), df['whatsapp_especiallyclose'].mean(),
    df['sms_merelyclose'].mean(), df['mms_merelyclose'].mean(), df['whatsapp_merelyclose'].mean(),
    df['sms_lessthanclose'].mean(), df['mms_lessthanclose'].mean(), df['whatsapp_lessthanclose'].mean(),
    df['sms_distant'].mean(), df['mms_distant'].mean(), df['whatsapp_distant'].mean(),
    df['sms_blank'].mean(), df['mms_blank'].mean(), df['whatsapp_blank'].mean()
] + [

    df['sms_acquaintance'].mean(), df['sms_comemberorganization'].mean(), df['sms_coworker'].mean(), df['sms_friend'].mean(),
    df['sms_neighbor'].mean(), df['sms_otherfamily'].mean(), df['sms_romanticpartner'].mean(), df['sms_parent'].mean(),
    df['sms_stepparent'].mean(), df['sms_sibling'].mean(), df['sms_stepsibling'].mean(), df['sms_blank'].mean(),
    df['mms_acquaintance'].mean(), df['mms_comemberorganization'].mean(), df['mms_coworker'].mean(), df['mms_friend'].mean(),
    df['mms_neighbor'].mean(), df['mms_otherfamily'].mean(), df['mms_romanticpartner'].mean(), df['mms_parent'].mean(),
    df['mms_stepparent'].mean(), df['mms_sibling'].mean(), df['mms_stepsibling'].mean(), df['mms_blank'].mean(),
    df['whatsapp_acquaintance'].mean(), df['whatsapp_comemberorganization'].mean(),df['whatsapp_coworker'].mean(), df['whatsapp_friend'].mean(), df['whatsapp_neighbor'].mean(),
    df['whatsapp_otherfamily'].mean(), df['whatsapp_romanticpartner'].mean(),
    df['whatsapp_parent'].mean(), df['whatsapp_stepparent'].mean(), df['whatsapp_sibling'].mean(), df['whatsapp_stepsibling'].mean(),df['whatsapp_blank'].mean()
]

# Create and display the Sankey diagram
fig = go.Figure(data=[go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        line=dict(color='black', width=0.5),
        label=labels
    ),
    link=dict(
        source=source,
        target=target,
        value=value
    ))])

fig.update_layout(
    title_text='Message Communication Within 3 Hours Before Sleep',
    title_font_size=18,
    title_x=0.5,  # Centers the title
    font_size=14,
    width=1000,
    height=750,
    paper_bgcolor='white',
    plot_bgcolor='white',
    margin=dict(l=30, r=30, t=30, b=30)  # Adjust margins (left, right, top, bottom)
)
fig.show()
```

## Look Up With Limitation to 1 Neighbor

The following figure shows the categories of messages (SMS, MMS and WhatsApp) with **look up limited to closest one wave** of surveys three hours prior to sleep. We observe that messages with unidentified contacts decreased from **10.83** to **8.27.** The categories of identified contacts increased correspondingly.

```{python}
#| echo: false
#| warning: false
#| output: true
df=pd.read_csv("/Users/shaokangyang/Library/CloudStorage/OneDrive-Personal/Nethealth/Data/CNSA/combine/7/df7_3hr_br1.csv")
import plotly.graph_objs as go
# Combine and format labels with their mean values for each category
# Close Degree labels with their means
labels_close_degree = [
    f'Especially Close: {df["especiallyclose_m"].mean():.2f}',
    f'Merely Close: {df["merelyclose_m"].mean():.2f}',
    f'Less Than Close: {df["lessthanclose_m"].mean():.2f}',
    f'Distant: {df["distant_m"].mean():.2f}',
    f'Close Unknown: {df["close_unknown_m"].mean():.2f}'
]

# Message Type labels with their means
labels_message_type = [
    f'SMS: {df["sms"].mean():.2f}',
    f'MMS: {df["mms"].mean():.2f}',
    f'WhatsApp: {df["whatsapp"].mean():.2f}'
]

# Contact Type labels with their means
labels_contact_type = [
    f'Acquaintance: {df["acquaintance_m"].mean():.2f}',
    f'Co-member Organization: {df["comemberorganization_m"].mean():.2f}',
    f'Coworker: {df["coworker_m"].mean():.2f}',
    f'Friend: {df["friend_m"].mean():.2f}',
    f'Neighbor: {df["neighbor_m"].mean():.2f}',
    f'Other Family: {df["otherfamily_m"].mean():.2f}',
    f'Romantic: {df["romantic_m"].mean():.2f}',
    f'Parent: {df["parent_m"].mean():.2f}',
    f'Step Parent: {df["stepparent_m"].mean():.2f}',
    f'Sibling: {df["sibling_m"].mean():.2f}',
    f'Step Sibling: {df["stepsibling_m"].mean():.2f}',
    f'Relation Unknown: {df["rela_unknown_m"].mean():.2f}'
]

# Combine all labels for nodes
labels = labels_close_degree + labels_message_type + labels_contact_type

# Initialize the lists for the source, target, and value arrays for the Sankey diagram
source = [
    # Close Degree to Message Type
    0, 0, 0,  # Especially Close to SMS, MMS, WhatsApp
    1, 1, 1,  # Merely Close to SMS, MMS, WhatsApp
    2, 2, 2,  # Less Than Close to SMS, MMS, WhatsApp
    3, 3, 3,  # Distant to SMS, MMS, WhatsApp
    4, 4, 4   # Close Unknown to SMS, MMS, WhatsApp
] + [
    # Message Type to Contact Type
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  # SMS to all contact types
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  # MMS to all contact types
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7   # WhatsApp to all contact types
]

target = [
    # Close Degree to Message Type
    5, 6, 7,  # Especially Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Merely Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Less Than Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Distant to SMS, MMS, WhatsApp
    5, 6, 7   # Close Unknown to SMS, MMS, WhatsApp
] + [
    # Message Type to Contact Type
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  # SMS to all contact types
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  # MMS to all contact types
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19   # WhatsApp to all contact types
]

# Values for all connections (assuming you have these means calculated correctly in your DataFrame)
#Judge if any of the following columns are not in the dataframe, create them and fill them with 0
for col in ['sms_acquaintance', 'sms_comemberorganization', 'sms_coworker', 'sms_friend', 'sms_neighbor', 'sms_otherfamily', 'sms_romanticpartner', 'sms_parent', 'sms_stepparent', 'sms_sibling', 'sms_stepsibling', 'sms_blank', 'mms_acquaintance', 'mms_comemberorganization', 'mms_coworker', 'mms_friend', 'mms_neighbor', 'mms_otherfamily', 'mms_romanticpartner', 'mms_parent', 'mms_stepparent', 'mms_sibling', 'mms_stepsibling', 'mms_blank', 'whatsapp_acquaintance', 'whatsapp_comemberorganization', 'whatsapp_coworker', 'whatsapp_friend', 'whatsapp_neighbor', 'whatsapp_otherfamily', 'whatsapp_romanticpartner', 'whatsapp_parent', 'whatsapp_stepparent', 'whatsapp_sibling', 'whatsapp_stepsibling', 'whatsapp_blank']:
    if col not in df.columns:
        df[col] = 0
value = [
    # Close Degree to Message Type values
    df['sms_especiallyclose'].mean(), df['mms_especiallyclose'].mean(), df['whatsapp_especiallyclose'].mean(),
    df['sms_merelyclose'].mean(), df['mms_merelyclose'].mean(), df['whatsapp_merelyclose'].mean(),
    df['sms_lessthanclose'].mean(), df['mms_lessthanclose'].mean(), df['whatsapp_lessthanclose'].mean(),
    df['sms_distant'].mean(), df['mms_distant'].mean(), df['whatsapp_distant'].mean(),
    df['sms_blank'].mean(), df['mms_blank'].mean(), df['whatsapp_blank'].mean()
] + [

    df['sms_acquaintance'].mean(), df['sms_comemberorganization'].mean(), df['sms_coworker'].mean(), df['sms_friend'].mean(),
    df['sms_neighbor'].mean(), df['sms_otherfamily'].mean(), df['sms_romanticpartner'].mean(), df['sms_parent'].mean(),
    df['sms_stepparent'].mean(), df['sms_sibling'].mean(), df['sms_stepsibling'].mean(), df['sms_blank'].mean(),
    df['mms_acquaintance'].mean(), df['mms_comemberorganization'].mean(), df['mms_coworker'].mean(), df['mms_friend'].mean(),
    df['mms_neighbor'].mean(), df['mms_otherfamily'].mean(), df['mms_romanticpartner'].mean(), df['mms_parent'].mean(),
    df['mms_stepparent'].mean(), df['mms_sibling'].mean(), df['mms_stepsibling'].mean(), df['mms_blank'].mean(),
    df['whatsapp_acquaintance'].mean(), df['whatsapp_comemberorganization'].mean(),df['whatsapp_coworker'].mean(), df['whatsapp_friend'].mean(), df['whatsapp_neighbor'].mean(),
    df['whatsapp_otherfamily'].mean(), df['whatsapp_romanticpartner'].mean(),
    df['whatsapp_parent'].mean(), df['whatsapp_stepparent'].mean(), df['whatsapp_sibling'].mean(), df['whatsapp_stepsibling'].mean(),df['whatsapp_blank'].mean()
]

# Create and display the Sankey diagram
fig = go.Figure(data=[go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        line=dict(color='black', width=0.5),
        label=labels
    ),
    link=dict(
        source=source,
        target=target,
        value=value
    ))])

fig.update_layout(
    title_text='Message Communication Within 3 Hours Before Sleep (Neighbor 1 Network)',
    title_font_size=18,
    title_x=0.5,  # Centers the title
    font_size=14,
    width=1000,
    height=750,
    paper_bgcolor='white',
    plot_bgcolor='white',
    margin=dict(l=30, r=30, t=30, b=30)  # Adjust margins (left, right, top, bottom)
)
fig.show()
```

## Look Up With Full Network

The following figure shows the categories of messages (SMS, MMS and WhatsApp) with look up in **full** social network surveys three hours prior to sleep. We observe that messages with unidentified contacts further decreased from **8.27** to **6.73.** The categories of identified contacts increased correspondingly.

```{python}
#| echo: false
#| warning: false
#| output: true
df=pd.read_csv("/Users/shaokangyang/Library/CloudStorage/OneDrive-Personal/Nethealth/Data/CNSA/combine/7/df7_3hr_full.csv")
import plotly.graph_objs as go
# Combine and format labels with their mean values for each category
# Close Degree labels with their means
labels_close_degree = [
    f'Especially Close: {df["especiallyclose_m"].mean():.2f}',
    f'Merely Close: {df["merelyclose_m"].mean():.2f}',
    f'Less Than Close: {df["lessthanclose_m"].mean():.2f}',
    f'Distant: {df["distant_m"].mean():.2f}',
    f'Close Unknown: {df["close_unknown_m"].mean():.2f}'
]

# Message Type labels with their means
labels_message_type = [
    f'SMS: {df["sms"].mean():.2f}',
    f'MMS: {df["mms"].mean():.2f}',
    f'WhatsApp: {df["whatsapp"].mean():.2f}'
]

# Contact Type labels with their means
labels_contact_type = [
    f'Acquaintance: {df["acquaintance_m"].mean():.2f}',
    f'Co-member Organization: {df["comemberorganization_m"].mean():.2f}',
    f'Coworker: {df["coworker_m"].mean():.2f}',
    f'Friend: {df["friend_m"].mean():.2f}',
    f'Neighbor: {df["neighbor_m"].mean():.2f}',
    f'Other Family: {df["otherfamily_m"].mean():.2f}',
    f'Romantic: {df["romantic_m"].mean():.2f}',
    f'Parent: {df["parent_m"].mean():.2f}',
    f'Step Parent: {df["stepparent_m"].mean():.2f}',
    f'Sibling: {df["sibling_m"].mean():.2f}',
    f'Step Sibling: {df["stepsibling_m"].mean():.2f}',
    f'Relation Unknown: {df["rela_unknown_m"].mean():.2f}'
]

# Combine all labels for nodes
labels = labels_close_degree + labels_message_type + labels_contact_type

# Initialize the lists for the source, target, and value arrays for the Sankey diagram
source = [
    # Close Degree to Message Type
    0, 0, 0,  # Especially Close to SMS, MMS, WhatsApp
    1, 1, 1,  # Merely Close to SMS, MMS, WhatsApp
    2, 2, 2,  # Less Than Close to SMS, MMS, WhatsApp
    3, 3, 3,  # Distant to SMS, MMS, WhatsApp
    4, 4, 4   # Close Unknown to SMS, MMS, WhatsApp
] + [
    # Message Type to Contact Type
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  # SMS to all contact types
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  # MMS to all contact types
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7   # WhatsApp to all contact types
]

target = [
    # Close Degree to Message Type
    5, 6, 7,  # Especially Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Merely Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Less Than Close to SMS, MMS, WhatsApp
    5, 6, 7,  # Distant to SMS, MMS, WhatsApp
    5, 6, 7   # Close Unknown to SMS, MMS, WhatsApp
] + [
    # Message Type to Contact Type
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  # SMS to all contact types
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  # MMS to all contact types
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19   # WhatsApp to all contact types
]

# Values for all connections (assuming you have these means calculated correctly in your DataFrame)
#Judge if any of the following columns are not in the dataframe, create them and fill them with 0
for col in ['sms_acquaintance', 'sms_comemberorganization', 'sms_coworker', 'sms_friend', 'sms_neighbor', 'sms_otherfamily', 'sms_romanticpartner', 'sms_parent', 'sms_stepparent', 'sms_sibling', 'sms_stepsibling', 'sms_blank', 'mms_acquaintance', 'mms_comemberorganization', 'mms_coworker', 'mms_friend', 'mms_neighbor', 'mms_otherfamily', 'mms_romanticpartner', 'mms_parent', 'mms_stepparent', 'mms_sibling', 'mms_stepsibling', 'mms_blank', 'whatsapp_acquaintance', 'whatsapp_comemberorganization', 'whatsapp_coworker', 'whatsapp_friend', 'whatsapp_neighbor', 'whatsapp_otherfamily', 'whatsapp_romanticpartner', 'whatsapp_parent', 'whatsapp_stepparent', 'whatsapp_sibling', 'whatsapp_stepsibling', 'whatsapp_blank']:
    if col not in df.columns:
        df[col] = 0
value = [
    # Close Degree to Message Type values
    df['sms_especiallyclose'].mean(), df['mms_especiallyclose'].mean(), df['whatsapp_especiallyclose'].mean(),
    df['sms_merelyclose'].mean(), df['mms_merelyclose'].mean(), df['whatsapp_merelyclose'].mean(),
    df['sms_lessthanclose'].mean(), df['mms_lessthanclose'].mean(), df['whatsapp_lessthanclose'].mean(),
    df['sms_distant'].mean(), df['mms_distant'].mean(), df['whatsapp_distant'].mean(),
    df['sms_blank'].mean(), df['mms_blank'].mean(), df['whatsapp_blank'].mean()
] + [

    df['sms_acquaintance'].mean(), df['sms_comemberorganization'].mean(), df['sms_coworker'].mean(), df['sms_friend'].mean(),
    df['sms_neighbor'].mean(), df['sms_otherfamily'].mean(), df['sms_romanticpartner'].mean(), df['sms_parent'].mean(),
    df['sms_stepparent'].mean(), df['sms_sibling'].mean(), df['sms_stepsibling'].mean(), df['sms_blank'].mean(),
    df['mms_acquaintance'].mean(), df['mms_comemberorganization'].mean(), df['mms_coworker'].mean(), df['mms_friend'].mean(),
    df['mms_neighbor'].mean(), df['mms_otherfamily'].mean(), df['mms_romanticpartner'].mean(), df['mms_parent'].mean(),
    df['mms_stepparent'].mean(), df['mms_sibling'].mean(), df['mms_stepsibling'].mean(), df['mms_blank'].mean(),
    df['whatsapp_acquaintance'].mean(), df['whatsapp_comemberorganization'].mean(),df['whatsapp_coworker'].mean(), df['whatsapp_friend'].mean(), df['whatsapp_neighbor'].mean(),
    df['whatsapp_otherfamily'].mean(), df['whatsapp_romanticpartner'].mean(),
    df['whatsapp_parent'].mean(), df['whatsapp_stepparent'].mean(), df['whatsapp_sibling'].mean(), df['whatsapp_stepsibling'].mean(),df['whatsapp_blank'].mean()
]

# Create and display the Sankey diagram
fig = go.Figure(data=[go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        line=dict(color='black', width=0.5),
        label=labels
    ),
    link=dict(
        source=source,
        target=target,
        value=value
    ))])
fig.update_layout(
    title_text='Message Communication Within 3 Hours Before Sleep (Full Network)',
    title_font_size=18,
    title_x=0.5,  # Centers the title
    font_size=14,
    width=1000,
    height=750,
    paper_bgcolor='white',
    plot_bgcolor='white',
    margin=dict(l=30, r=30, t=30, b=30)  # Adjust margins (left, right, top, bottom)
)
fig.show()
```

## Estimation Results with Different Lookup Scopes

In this section, we show the estimation results with different lookup scopes.

### Main Results without Lookup (3 Hrs)

![Impact of Smartphone Use On Sleep Debt without Lookup (3 Hrs)](images/original.png){fig-align="center"}

### Main Results with Lookup in Neighbor 1 Network (3 Hrs)

![Impact of Smartphone Use On Sleep Debt with Lookup in Neighbor 1 Network (3 Hrs)](images/neighbor1.png){fig-align="center"}

### Main Results with Lookup in Full Network (3 Hrs)

![Impact of Smartphone Use On Sleep Debt with Lookup in Full Network (3 Hrs)](images/full.png){fig-align="center"}

In general, we find that the estimation results are generally consistent across different lookup strategies.
